package CertReader::App::UpdateValidityTable;

# Build a table that allows quick access to the validity status of certificates

use forks; # ALWAYS LOAD AS FIRST MODULE, if possible
# Tell Forks::Queue to not play signal bomb
# Alternatively to disabling signals for queue signaling is to ensure a sufficiently
# Large stepsize such that not too many elements are withdrawn from the queue while
# a thread blocks, e.g., while waiting for response of the database. However, calculating
# an appropriate stepsize is quite system and situation dependent.
BEGIN { $ENV{FORKS_QUEUE_NOTIFY} = 0; } # Tell Forks::Queue to not play signal bomb
use Forks::Queue;
my $nworker = 5;
my $stepsize = 10000;

use 5.14.1;
use strict;
use warnings;

use Carp;
use Data::Dumper;
use FileHandle;
use List::Util qw[min max];

use open ':std', ':encoding(UTF-8)';
use Scalar::Util;
use POSIX;

use Moose;

use Crypt::OpenSSL::X509;

use CertReader::DB::CertificateValidity;
use CertReader::DB::VerifyTree;
with 'CertReader::Base';
with 'CertReader::CA';
# with 'CertReader::CertCache';

has 'nworker' => (
	is => 'rw',
	isa => 'Int',
	required => 1,
	default => $nworker,
	documentation => "Number of threads. Default: $nworker",
);

has 'stepsize' => (
	is => 'rw',
	isa => 'Int',
	required => 1,
	default => $stepsize,
	documentation => "Maximum number of lines requested from the database in one query. Default: $stepsize",
);

has 'verbosity' => (
	is => 'rw',
	isa => 'Int',
	default => 0,
	documentation => 'Verbosity of log output',
);

has 'timestamp_start' => (
	is => 'ro',
	isa => 'Str',
	default => sub { POSIX::strftime("%F_%Hh-%Mm-%Ss%z", localtime()) },
	documentation => 'Timestamp at time of script startup',
);

has 'do_not_overwrite_valid_with_invalid' => (
	is => 'ro',
	isa => 'Bool',
	default => 0,
	documentation => '',
);

has 'start_with_certid' => (
	is => 'rw',
	isa => 'Int',
	required => 0,
	default => 0,
	documentation => "Skip all certificates with id smaller than given. Usually only needed to resume work.",
);

# TODO attime support?
sub run {
	my $self = shift;

	STDOUT->autoflush(1);
	STDERR->autoflush(1);

	say "Startup time: " . $self->timestamp_start;

	$self->populate_certificate_validity;

	exit(0);
}

sub disconnect_db_handlers {
	# This function must be called before forking!
	# Otherwise, the clients will close the database handle such that the parent
	# fails upon its next usage of the database connection. Hence, we close all
	# DB connections before a fork, and restore them afterwards such that the parent
	# and each worker have their own database handles.
	# Note that InactiveDestroy and AutoInactiveDestroy seem to be unsuitable as
	# Rose::DB actively calls 'disconnect' on the handler, which still causes the
	# connection to be closed: https://metacpan.org/pod/DBI#InactiveDestroy

	my ($class, $self) = @_;

	my $db_objects = CertReader::DB->new_or_cached;
	my $db_orm = $self->db; # This was generated by CertReader::ORM
	$db_objects->dbh->disconnect;
	$db_orm->dbh->disconnect;

	my $disconnect_cnt = 2; # The number of disconnects triggered above

	# Sanity check if there are more db handlers than expected.
	# Note that we can find them this way, but as they are most probably generated
	# by Rose::DB we need to find the corresponding Rose::DB objects to be able
	# to reconnect them afterwards (see reconnect_db_handlers()), sorry.
	my %dbi_drivers = DBI->installed_drivers();
	my @parent_dbh = grep { defined } map { @{$_->{ChildHandles}} } values %dbi_drivers;
	if (scalar @parent_dbh > $disconnect_cnt) {
		croak("Found more dbi handlers than we closed");
	}
}

sub reconnect_db_handlers {
	# Reconnect the database using new generated connections.
	my ($class, $self) = @_;

	my $db_objects = CertReader::DB->new_or_cached;
	my $db_orm = $self->db;

	my $new_dbh_objects = CertReader::DB->new()->retain_dbh
		or die Rose::DB->error;
	$db_objects->dbh($new_dbh_objects);
	my $new_dbh_orm = CertReader::DB->new()->retain_dbh
		or die Rose::DB->error;
	$db_orm->dbh($new_dbh_orm);
}

sub populate_certificate_validity {
	my $self = shift;
	my $postfix = $self->tablepostfix;
	my $batchsize = $stepsize;

	say "Iterating over all certificates to update validity database table";

	my $certid_max = CertReader::DB::Certificate::Manager->get_certificate_id_max($self->db, $self->tablepostfix);

	my $currid = 0;
	my $lastid = -1;
	say "\tWe will iterate over a total of $certid_max certificates in batches of $batchsize.";

	if ($self->start_with_certid) {
		$currid = $self->start_with_certid;
	}

	my $certbatch_queue = Forks::Queue->new( impl => 'Shmem' );
	while( $lastid < $certid_max ) {
		$lastid = min($currid + ($stepsize - 1), $certid_max);
		$certbatch_queue->enqueue([$currid, $lastid]);
		$currid = $lastid + 1;
	}
	$certbatch_queue->end();

	CertReader::App::UpdateValidityTable->disconnect_db_handlers($self);
	for ( 1 .. $self->nworker ) {
		threads->create( {'context' => 'list'}, \&update_validity_worker, $self, $certbatch_queue );
	}

	say "Waiting for worker to finish their work ...";
	foreach my $thr ( threads->list() ) {
		my $ret = $thr->join();
		if (!defined($ret)) {
			croak("error in update_validity_worker: Exited abnormally")
		}
		if ($ret != 0) {
			croak("error in update_validity_worker: $ret")
		}
	}
	say "All worker finished";

	CertReader::App::UpdateValidityTable->reconnect_db_handlers($self);
	say "\tdone.";

}

sub update_validity_worker {
	my ($self, $certbatch_queue) = @_;
	my $postfix = $self->tablepostfix;
	my $prefix = "Worker " . threads->self()->tid() . ":";
	say "$prefix started.";

	CertReader::App::UpdateValidityTable->reconnect_db_handlers($self);

	while ( my $in = $certbatch_queue->dequeue() ) {
		my ($currid, $lastid) = @$in;

		say "\t" . localtime() . "    $prefix analyzing certs $currid - $lastid";

		my $sql = "select * from certificate_$postfix where id >= $currid and id <= $lastid order by id asc;";
		my $certiter = CertReader::DB::Certificate::Manager->get_certificates_iterator_from_sql(
			db => $self->db,
			inject_results => 1,
			sql => $sql,
		);

		my @db_write_queue;

		while ( my $cert = $certiter->next ) {
			# if (!defined($cert->subject) or !defined($cert->key_mod)) {
			# 	next;
			# }

			my $valid = 0;
			if ($cert->is_valid($postfix) != 0) {
				$valid = 1;
			}

			# note that each certificate is handled by exactly one worker (and only once), so there is no need to lock the DB
			my $cert_validity_db_entry = CertReader::DB::CertificateValidity::Manager->get_certificate_validity_for_certid($self->db, $self->tablepostfix, $cert->id);
			if (!$cert_validity_db_entry) {
				$cert_validity_db_entry = CertReader::DB::CertificateValidity->new(
					certificate => $cert->id,
					valid => $valid,
					);
				$cert_validity_db_entry->save;
			} else {
				if ($cert_validity_db_entry->valid != $valid) {
					if ($valid or (not $self->do_not_overwrite_valid_with_invalid)) {
						$cert_validity_db_entry->valid($valid);
						$cert_validity_db_entry->save;
					}
				}
			}

		}

	}

	say "$prefix finished.";

	return 0;
}

1;
