package CertReader::App::CheckCAcertPathlen;

# Find paths of CA certs that make the CA cert valid but do not allow the CA cert
# to issue valid (CA or leaf) certificates due to pathlen restrictions.
# Notes:
#   - A pathlen of the trust anchor (root) is ignored (cf. RFC 5280)
#   - X509_verify_certs already checked the pathlen in general when we created
#     the chains
#   - We still need to check one thing:
#     Assume we have chain R->I1->I2->L and I1 has pathlen=0, then the path
#     R->I1->I2 makes I2 valid, as pathlen=0 still allows I1 to issue one cert.
#     However, R->I1->I2->L is not valid as the pathlen restriction does not
#     allow I2 to issue a valid certificate.
#     See ../../../../openssl_pathlen-tests for an example that demonstrates
#     this behavior using openssl
#     Hence, our goal here is the following:
#       for each CA cert:
#         for all chains of this CA cert:
#           check if the pathlen restrictions allow the CA cert to issue a valid cert


use forks; # ALWAYS LOAD AS FIRST MODULE, if possible
# Tell Forks::Queue to not play signal bomb
# Alternatively to disabling signals for queue signaling is to ensure a sufficiently
# Large stepsize such that not too many elements are withdrawn from the queue while
# a thread blocks, e.g., while waiting for response of the database. However, calculating
# an appropriate stepsize is quite system and situation dependent.
BEGIN { $ENV{FORKS_QUEUE_NOTIFY} = 0; } # Tell Forks::Queue to not play signal bomb
use Forks::Queue;
my $nworker = 5;
my $stepsize = 10000;

use 5.14.1;
use strict;
use warnings;

use Carp;
use Data::Dumper;
use FileHandle;
use List::Util qw[min max];

use open ':std', ':encoding(UTF-8)';
use Scalar::Util;
use POSIX;

use Moose;

use Crypt::OpenSSL::X509;

use CertReader::DB::VerifyTree;
with 'CertReader::Base';
with 'CertReader::CA';
# with 'CertReader::CertCache';

has 'nworker' => (
    is => 'rw',
    isa => 'Int',
    required => 1,
    default => $nworker,
    documentation => "Number of threads. Default: $nworker",
);

has 'stepsize' => (
    is => 'rw',
    isa => 'Int',
    required => 1,
    default => $stepsize,
    documentation => "Maximum number of lines requested from the database in one query. Default: $stepsize",
);

has 'resultsdir' => (
    is => 'rw',
    isa => 'Str',
    required => 1,
    default => "./",
    documentation => "Select a parent directory that will be used to create the directory that will contain the results (default: .)",
);

has 'verbosity' => (
    is => 'rw',
    isa => 'Int',
    default => 0,
    documentation => 'Verbosity of log output',
);

has 'timestamp_start' => (
    is => 'ro',
    isa => 'Str',
    default => sub { POSIX::strftime("%F_%Hh-%Mm-%Ss%z", localtime()) },
    documentation => 'Timestamp at time of script startup',
);

# TODO attime support?
sub run {
    my $self = shift;

    STDOUT->autoflush(1);
    STDERR->autoflush(1);

    say "Startup time: " . $self->timestamp_start;

    $self->{log_dir} = $self->resultsdir . "/CheckCAcertPathlen_logs_" . $self->timestamp_start;
    say "Creating directory " . $self->{log_dir} . " for logs";
    croak("Could not create directory " . $self->{log_dir} . ": $!") if !mkdir($self->{log_dir});

    $self->check_cacert_pathlen;

    exit(0);
}

sub disconnect_db_handlers {
    # This function must be called before forking!
    # Otherwise, the clients will close the database handle such that the parent
    # fails upon its next usage of the database connection. Hence, we close all
    # DB connections before a fork, and restore them afterwards such that the parent
    # and each worker have their own database handles.
    # Note that InactiveDestroy and AutoInactiveDestroy seem to be unsuitable as
    # Rose::DB actively calls 'disconnect' on the handler, which still causes the
    # connection to be closed: https://metacpan.org/pod/DBI#InactiveDestroy

    my ($class, $self) = @_;

    my $db_objects = CertReader::DB->new_or_cached;
    my $db_orm = $self->db; # This was generated by CertReader::ORM
    $db_objects->dbh->disconnect;
    $db_orm->dbh->disconnect;

    my $disconnect_cnt = 2; # The number of disconnects triggered above

    # Sanity check if there are more db handlers than expected.
    # Note that we can find them this way, but as they are most probably generated
    # by Rose::DB we need to find the corresponding Rose::DB objects to be able
    # to reconnect them afterwards (see reconnect_db_handlers()), sorry.
    my %dbi_drivers = DBI->installed_drivers();
    my @parent_dbh = grep { defined } map { @{$_->{ChildHandles}} } values %dbi_drivers;
    if (scalar @parent_dbh > $disconnect_cnt) {
        croak("Found more dbi handlers than we closed");
    }
}

sub reconnect_db_handlers {
    # Reconnect the database using new generated connections.
    my ($class, $self) = @_;

    my $db_objects = CertReader::DB->new_or_cached;
    my $db_orm = $self->db;

    my $new_dbh_objects = CertReader::DB->new()->retain_dbh
        or die Rose::DB->error;
    $db_objects->dbh($new_dbh_objects);
    my $new_dbh_orm = CertReader::DB->new()->retain_dbh
        or die Rose::DB->error;
    $db_orm->dbh($new_dbh_orm);
}

sub check_cacert_pathlen {
    my $self = shift;
    my $postfix = $self->tablepostfix;
    my $batchsize = $stepsize;

    say "Iterating over all certificates to update validity database table";

    my $certid_max = CertReader::DB::Certificate::Manager->get_certificate_id_max($self->db, $self->tablepostfix);

    my $currid = 0;
    my $lastid = -1;
    say "\tWe will iterate over a total of $certid_max certificates in batches of $batchsize.";

    my $certbatch_queue = Forks::Queue->new( impl => 'Shmem' );
    while( $lastid < $certid_max ) {
        $lastid = min($currid + ($stepsize - 1), $certid_max);
        $certbatch_queue->enqueue([$currid, $lastid]);
        $currid = $lastid + 1;
    }
    $certbatch_queue->end();

    CertReader::App::CheckCAcertPathlen->disconnect_db_handlers($self);
    for ( 1 .. $self->nworker ) {
        threads->create( {'context' => 'list'}, \&check_cacert_pathlen_worker, $self, $certbatch_queue );
    }

    say "Waiting for worker to finish their work ...";
    foreach my $thr ( threads->list() ) {
        my $ret = $thr->join();
        if (!defined($ret)) {
            croak("error in check_cacert_pathlen_worker: Exited abnormally")
        }
        if ($ret != 0) {
            croak("error in check_cacert_pathlen_worker: $ret")
        }
    }
    say "All worker finished";

    CertReader::App::CheckCAcertPathlen->reconnect_db_handlers($self);
    say "\tdone.";

}

sub  trim { my $s = shift; $s =~ s/^\s+|\s+$//g; return $s };


sub check_cacert_pathlen_worker {
    my ($self, $certbatch_queue) = @_;
    my $postfix = $self->tablepostfix;
    my $prefix = "Worker " . threads->self()->tid() . ":";
    say "$prefix started.";

    my $log = $self->{log_dir} . "/worker" . threads->self()->tid() . "_log.txt";
    my $fh_log = FileHandle->new($log, '>:encoding(UTF-8)');
    croak("Could not open $log") if !defined($fh_log);
    $fh_log->autoflush(1);
    say {$fh_log} localtime() . "    $prefix started\n";

    CertReader::App::CheckCAcertPathlen->reconnect_db_handlers($self);

    while ( my $in = $certbatch_queue->dequeue() ) {
        my ($currid, $lastid) = @$in;

        say "\t" . localtime() . "    $prefix analyzing CA certs in cert range $currid - $lastid";

        my $sql = "select * from certificate_$postfix where ca = True and id >= $currid and id <= $lastid order by id asc;";
        my $certiter = CertReader::DB::Certificate::Manager->get_certificates_iterator_from_sql(
            db => $self->db,
            inject_results => 1,
            sql => $sql,
        );

        my @db_write_queue;

        while ( my $cert = $certiter->next ) {
            my $pathlen = $cert->get_pathlen;
            $pathlen = "" if !defined($pathlen);
            # say "\t" . localtime() . "    $prefix " . $cert->id . " $pathlen";

            my $sql_query = "select * from verify_tree_$self->{tablepostfix} where certificate = $cert->{id};";
            my $vtiter = CertReader::DB::VerifyTree::Manager->get_verifypaths_iterator_from_sql(
                db => $self->db,
                inject_results => 1,
                sql => $sql_query,
            );
            my $pathlen_by_certid = {};
            my $roots = {};
            while ( my $vt = $vtiter->next ) {
                my $debug_str = "";
                my $path = $vt->path;
                my $root = $vt->store;
                if ($self->verbosity > 0) {
                    $debug_str .= "\t" . localtime() . "    $prefix    path: $path\n";
                }
                my @chain = split(/\./, $path);
                my $rootcert = shift @chain; # ignore root
                if (!defined($roots->{$root})) {
                    $roots->{$root} = 0;
                }
                my $cur_pathlen = undef;
                for my $chain_cert_id (@chain) {
                    if (defined($cur_pathlen)) {
                        $cur_pathlen = $cur_pathlen - 1;
                    }
                    my $chain_cert_pathlen = undef;
                    if (defined($pathlen_by_certid->{$chain_cert_id})) {
                        $chain_cert_pathlen = $pathlen_by_certid->{$chain_cert_id};
                    } else {
                        my $key = 'id';
                        my $chain_cert = CertReader::DB::Certificate->new(db => $self->db, $key => $chain_cert_id);
                        $chain_cert->load();
                        $chain_cert_pathlen = $chain_cert->get_pathlen;
                        $pathlen_by_certid->{$chain_cert_id} = $chain_cert_pathlen;
                    }

                    if (defined($chain_cert_pathlen)) {
                        if (defined($cur_pathlen)) {
                            $cur_pathlen = min($cur_pathlen, $chain_cert_pathlen);
                        } else {
                            $cur_pathlen = $chain_cert_pathlen;
                        }
                    }
                    if ($self->verbosity > 0) {
                        $debug_str .= "\t" . localtime() . "    $prefix       cert: $chain_cert_id  ";
                        $debug_str .= "cert_pathlen: ";
                        if (defined($chain_cert_pathlen)) {
                            $debug_str .= $chain_cert_pathlen;
                        } else {
                            $debug_str .= "undef";
                        }
                        $debug_str .= " cur_pathlen: ";
                        if (defined($cur_pathlen)) {
                            $debug_str .= $cur_pathlen;
                        } else {
                            $debug_str .= "undef";
                        }
                        $debug_str .= "\n";
                    }
                }

                my $ok = 0;
                if (defined($cur_pathlen)) {
                    # say $debug_str;
                    if ($cur_pathlen >= 0) {
                        $ok = 1;
                        # say "\t" . localtime() . "    $prefix       OK";
                        # that is fine, the last CA-cert in the chain can still
                        # issue a valid certificate
                    } else {
                        if ($cur_pathlen == -1) {
                            if ($self->verbosity > 0) {
                                $debug_str .= "WARNING encountered pathlen == -1: $cert->{id}, $path";
                            }
                        } else {
                            # This must not happen.
                            # This means that the openssl-based verification deemed a path valid for
                            # which the pathlen is less than 0 at the "leaf" CA-cert of the chain.
                            # By RFC 5280, such a chain is invalid and thus must not exist in our database.
                            $debug_str .= "ERROR encountered negative pathlen == $cur_pathlen: $cert->{id}, $path";
                            croak($debug_str);
                        }
                        if ($self->verbosity > 0) {
                            say $debug_str;
                            say {$fh_log} localtime() . $debug_str;
                        }
                    }
                } else {
                    $ok = 1;
                }
                if ($ok) {
                    $roots->{$root} = 1;
                }

            }

            # Check if for any root, no path allows to issue another cert
            my $deep_check = 0;
            for my $root (keys %$roots) {
                if (! $roots->{$root}) {
                    $deep_check = 1;
                    last;
                }
            }
            if ($deep_check) {
                my $cannot_issue_roots = "";
                my $can_issue_roots = "";
                my $affected_stores = "";
                my $store_coverage = {};
                for my $root (keys %$roots) {
                    if (! $roots->{$root}) {
                        $cannot_issue_roots .= "$root ";
                    } else {
                        $can_issue_roots .= " $root";
                    }

                    my $root_db = CertReader::DB::RootCerts->new(db => $self->db, id => $root);
                    $root_db->load();
                    for my $store (@{$root_db->stores}) {
                        if ($roots->{$root}) {
                            $store_coverage->{$store} = 1;
                        } else {
                            if (!defined($store_coverage->{$store})) {
                                $store_coverage->{$store} = 0;
                            }
                        }
                    }
                }
                for my $store (sort keys %$store_coverage) {
                    if (! $store_coverage->{$store}) {
                        $affected_stores .= "$store ";
                    }
                }
                my $csc_ids = "";
                my $csc_cert_iterator = CertReader::DB::CrossSignCandidateCert::Manager->get_csc_cert_iterator_for_cert($self->db, $self->tablepostfix, $cert);
                while (my $csc_cert = $csc_cert_iterator->next) {
                    $csc_ids .= $csc_cert->csc_id . " ";
                }
                my $deep_check_out = "";
                $deep_check_out .= "    $prefix  WARNING cert $cert->{id} (csc_ids: $csc_ids) cannot issue for roots $cannot_issue_roots [ok:$can_issue_roots]\n";
                $deep_check_out .= "    $prefix      affected stores: $affected_stores\n";
                say $deep_check_out;
                say {$fh_log} localtime() . $deep_check_out;

            }

        }

    }

    say "$prefix finished.";

    return 0;
}

1;
